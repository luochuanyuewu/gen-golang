{{define "server"}}
{{- $typeMap := .TypeMap -}}
{{- if .Services }}
//
// Server
//

type WebRPCServer interface {
  ServeGin(ctx *gin.Context)
}


{{- range .Services}}
{{- $name := .Name -}}
{{ $serviceName := (printf "%sServer" (.Name | firstLetterToLower)) }}

type {{$serviceName}} struct {
	{{.Name}}
}

func New{{ .Name | firstLetterToUpper }}Server(svc {{.Name}}) WebRPCServer {
	return &{{$serviceName}}{
		{{.Name}}: svc,
	}
}

func (s *{{$serviceName}}) ServeGin(ctx *gin.Context) {
    ctx.Set(HTTPResponseWriterCtxKey.name, ctx.Writer)
    ctx.Set(HTTPRequestCtxKey.name, ctx.Request)
    ctx.Set(ServiceNameCtxKey.name, "{{.Name}}")

	if ctx.Request.Method != "POST" {
		err := ErrorWithCause(ErrWebrpcBadMethod, fmt.Errorf("unsupported method %q (only POST is allowed)", ctx.Request.Method))
		RespondWithError(ctx, err)
		return
	}

	switch ctx.Request.URL.Path {
	{{- range .Methods}}
	case "/rpc/{{$name}}/{{.Name}}":
		s.serve{{.Name | firstLetterToUpper}}(ctx)
		return
	{{- end}}
	default:
		err := ErrorWithCause(ErrWebrpcBadRoute, fmt.Errorf("no handler for path %q", ctx.Request.URL.Path))
		RespondWithError(ctx, err)
		return
	}
}
{{range .Methods }}
func (s *{{$serviceName}}) serve{{.Name | firstLetterToUpper}}(ctx *gin.Context) {
	header := ctx.GetHeader("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serve{{ .Name | firstLetterToUpper }}JSON(ctx)
	default:
		err := ErrorWithCause(ErrWebrpcBadRequest, fmt.Errorf("unexpected Content-Type: %q", ctx.GetHeader("Content-Type")))
		RespondWithError(ctx, err)
	}
}

func (s *{{$serviceName}}) serve{{ .Name | firstLetterToUpper }}JSON(ctx *gin.Context) {
	var err error
	ctx.Set(MethodNameCtxKey.name, "{{.Name}}")

	{{- if .Inputs|len}}
	reqContent := struct {
	{{- range $i, $input := .Inputs}}
		Arg{{$i}} {{template "type" dict "Type" $input.Type "Optional" $input.Optional "TypeMap" $typeMap}} `json:"{{firstLetterToLower $input.Name}}"`
	{{- end}}
	}{}

 	if err := ctx.ShouldBindJSON(&reqContent); err != nil {
		err2 := ErrorWithCause(ErrWebrpcBadRequest, fmt.Errorf("failed to unmarshal request data: %w", err))
		RespondWithError(ctx, err2)
		return
	}
	{{- end}}

	// Call service method
	{{- range $i, $output := .Outputs}}
	var ret{{$i}} {{template "type" dict "Type" $output.Type "Optional" $output.Optional "TypeMap" $typeMap}}
	{{- end}}
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(ctx, ErrorWithCause(ErrWebrpcServerPanic, fmt.Errorf("%v", rr)))
				panic(rr)
			}
		}()
		{{range $i, $output := .Outputs}}ret{{$i}}, {{end}}err = s.{{$name}}.{{.Name}}(ctx{{range $i, $_ := .Inputs}}, reqContent.Arg{{$i}}{{end}})
	}()
	{{- if .Outputs | len}}
	respContent := struct {
	{{- range $i, $output := .Outputs}}
		Ret{{$i}} {{template "type" dict "Type" $output.Type "Optional" $output.Optional "TypeMap" $typeMap}} `json:"{{firstLetterToLower $output.Name}}"`
	{{- end}}
	}{ {{- range $i, $_ := .Outputs}}{{if gt $i 0}}, {{end}}ret{{$i}}{{end}}}
	{{- end}}

	if err != nil {
		RespondWithError(ctx, err)
		return
	}

	{{- if .Outputs | len}}
	ctx.JSON(http.StatusOK, respContent)
	{{- end}}
}
{{end}}
{{end -}}

func RespondWithError(ctx *gin.Context, err error) {
	rpcErr, ok := err.(WebRPCError)
	if !ok {
		rpcErr = ErrorWithCause(ErrWebrpcEndpoint, err)
	}

    ctx.JSON(rpcErr.HTTPStatus, rpcErr)
}

{{- end -}}
{{- end -}}
